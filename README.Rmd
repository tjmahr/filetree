---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# filetree

<!-- badges: start -->
<!-- badges: end -->

A (currently) largely **vibecoded** package for declarative filetrees. This
package is mostly a proof-of-concept or an API experiment. Contributions:

- ðŸ¤–: R code, roxygen2 descriptions
- ðŸ¤“: README, DESCRIPTION, tests

As I review and refactor things, they will move from robot to nerd.


## Installation

You can install the development version of filetree from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("tjmahr/filetree")
```

## Example

Here is some data organized into nice folders.

```{r demo}
"./inst/demo-1" |> 
  fs::dir_tree(recurse = TRUE)
```

We set up the filetree with `ft_init()`. Each *layer* is a level of hierarchy. At
the root, when we list the folders, we see subjects. So the first layer is
`"subject"`. Inside of a subject folder, when we list the folders, we see time
points. The layer is therefore `"time"`. Finally, in the last level, we see out
main data files, so we call this layer `"data"`. 

```{r}
library(filetree)

ft <- ft_init(
  root = "./inst/demo-1", 
  layers = c("subject", "time", "data")
)
ft
```

Now, we define the patterns. First, we register and store regexes. These can be
reused in patterns so we can describe things very succinctly. For example, after
defining the regexes `subject` and `task`, we can say that files have the
pattern `"{subject}_{task}.txt"`.

```{r}
ft <- ft |>
  ft_add_regex(c(
    subject = "\\w{2}-\\d{2}",
    time = "day\\d{2}",
    task = "red|green"
  )) |> 
  ft_add_dir_pattern(
    layer = "time", 
    patterns = "{time}"
  ) |> 
  ft_add_dir_pattern(
    layer = "subject", 
    patterns = "{subject}"
  ) |> 
  ft_add_file_pattern(
    layer = "data",  
    patterns = "{subject}_{task}.txt"
  )
ft
```

Now we can validate and parse the file names.

```{r}
# Look at the files
ft |> ft_list() |> fs::path_rel()

ft |> ft_index()
```


For comparison, here is a file tree with some problems. There is

- a misformatted day folder
- a file with the wrong subject
- a file with a nonexisting task ("blue")

```{r}
ft <- "./inst/demo-2" |> 
  ft_init(c("subject", "time", "data")) |>
  ft_add_regex(c(
    subject = "\\w{2}-\\d{2}",
    time = "day\\d{2}",
    task = "red|green"
  )) |> 
  ft_add_dir_pattern("time", "{time}") |> 
  ft_add_dir_pattern("subject", "{subject}") |> 
  ft_add_file_pattern("data", "{subject}_{task}.txt")

ft |> 
  ft_index() |> 
  dplyr::filter(!.ok) |> 
  split(~.rel) |> 
  lapply(dplyr::pull, .problems)
```

The following example is meant to demonstrate how regexes define fields and
those fields need to be consistent along a path.

In the `time` layer, folders are named `day{time}`. In the data layer, files are named `"{subject}_{time}_{task}.txt"`. In this demo, there is a file where the time values don't match:

```{r}
ft <- "./inst/demo-3" |> 
  ft_init(c("subject", "time", "data")) |>
  ft_add_regex(c(
    subject = "\\w{2}-\\d{2}",
    time = "\\d{2}",
    task = "red|green"
  )) |> 
  ft_add_dir_pattern("time", "day{time}") |> 
  ft_add_dir_pattern("subject", "{subject}") |> 
  ft_add_file_pattern("data", "{subject}_{time}_{task}.txt")

ft |> 
  ft_index() |> 
  dplyr::filter(!.ok) |> 
  split(~.rel) |> 
  lapply(dplyr::pull, .problems)
```

Because the parsed out layers and fields need to kept separate, we get a lot of columns now: 

```{r}
ft |> 
  ft_index() |> 
  dplyr::glimpse()
```


## Current impressions

I have been using this tool validate our speech corpus data on our network 
drives. The `ft_index()` operation is very expensive in this case because 
of the network access and the thousands upon thousands of files at play. I've 
found it better to instead do something like:

```{r}
files_to_check <- fs::dir_ls(ft$root, recurse = TRUE, type = "file")
results <- ft_index(ft, files_to_check)

# Even faster to prefilter the tree if we are just interested in a particular
# set of files
files_to_check <- ft$root |> 
  fs::dir_ls(recurse = TRUE, type = "file", regexp = ".txt$")

results <- ft_index(ft, files_to_check)
```


***

It would be nice to 

- [ ] check inventory/completeness. (Did you notice a missing "red" file in the
  first tree?)
  
- [ ] constrain parent folder. (Maybe a "yellow" is given on and only on day 3.)
  Or is that more of a dplyr-layer move for validation?

- [ ] add validation that we can reconstruct `.rel` from the concatenation of 
  each layer?
  
- [ ] having a really good and fast way to see the problem files

